import logging
from contextlib import asynccontextmanager
from typing import Optional

import project.get_user_profile_service
import project.login_user_service
import project.register_user_service
import project.stream_video_service
import project.update_user_profile_service
import project.upload_video_service
from fastapi import FastAPI, UploadFile
from fastapi.encoders import jsonable_encoder
from fastapi.responses import Response
from prisma import Prisma

logger = logging.getLogger(__name__)

db_client = Prisma(auto_register=True)


@asynccontextmanager
async def lifespan(app: FastAPI):
    await db_client.connect()
    yield
    await db_client.disconnect()


app = FastAPI(
    title="video api",
    lifespan=lifespan,
    description="To develop an API that serves a video based on a simple authorization system using the specified tech stack (Python, FastAPI, PostgreSQL, and Prisma), a clear plan of action has been established from the gathered information. The system encompasses a simplistic yet secure authorization mechanism catering directly to a singular user role setup, negating the need for public video access without authorization. \n\nKey implementation steps derived from the responses and research include:\n\n1. **Authorization Mechanism**: Implementing a basic authorization system within FastAPI, utilizing OAuth2 with Password and Bearer with JWT tokens for secure user authentication. This setup will ensure that only authorized users can access the video content.\n\n2. **User Management**: Leveraging PostgreSQL managed through Prisma ORM to create a users table that will store user credentials securely. This step includes handling user authentication and role-based access control mechanisms.\n\n3. **Secure Video Serving**: Ensuring video content is served over HTTPS to encrypt data transmission and considering the use of signed URLs for each video content. This approach will help in preventing unauthorized access and sharing of the video content.\n\n4. **Security Practices**: Employing best practices in securing the API, including the management of sensitive information through environment variables or secret management tools, updating dependencies regularly to mitigate vulnerabilities, and creating comprehensive tests covering authentication and authorization logic.\n\n5. **Simple Client-Server Communication**: The system will allow for a randomized header, easily generated by the client alongside the server, thus facilitating a simple yet secure method for accessing videos.\n\nThe collected inputs and researched data have significantly contributed to forming a comprehensive project plan focused on simplicity, security, and efficiency, aligning with the userâ€™s initial vision.",
)


@app.post(
    "/auth/register", response_model=project.register_user_service.RegisterUserResponse
)
async def api_post_register_user(
    email: str, password: str, username: str
) -> project.register_user_service.RegisterUserResponse | Response:
    """
    Registers a new user into the system.
    """
    try:
        res = await project.register_user_service.register_user(
            email, password, username
        )
        return res
    except Exception as e:
        logger.exception("Error processing request")
        res = dict()
        res["error"] = str(e)
        return Response(
            content=jsonable_encoder(res),
            status_code=500,
            media_type="application/json",
        )


@app.post(
    "/video/upload", response_model=project.upload_video_service.UploadVideoResponse
)
async def api_post_upload_video(
    title: str, description: Optional[str], video_file: UploadFile
) -> project.upload_video_service.UploadVideoResponse | Response:
    """
    Securely uploads a new video to the system.
    """
    try:
        res = await project.upload_video_service.upload_video(
            title, description, video_file
        )
        return res
    except Exception as e:
        logger.exception("Error processing request")
        res = dict()
        res["error"] = str(e)
        return Response(
            content=jsonable_encoder(res),
            status_code=500,
            media_type="application/json",
        )


@app.post("/auth/login", response_model=project.login_user_service.LoginResponse)
async def api_post_login_user(
    password: str, email: str
) -> project.login_user_service.LoginResponse | Response:
    """
    Authenticates a user and returns a JWT token.
    """
    try:
        res = await project.login_user_service.login_user(password, email)
        return res
    except Exception as e:
        logger.exception("Error processing request")
        res = dict()
        res["error"] = str(e)
        return Response(
            content=jsonable_encoder(res),
            status_code=500,
            media_type="application/json",
        )


@app.get(
    "/video/stream/{videoId}",
    response_model=project.stream_video_service.StreamVideoResponse,
)
async def api_get_stream_video(
    videoId: str,
) -> project.stream_video_service.StreamVideoResponse | Response:
    """
    Streams video content to the client.
    """
    try:
        res = await project.stream_video_service.stream_video(videoId)
        return res
    except Exception as e:
        logger.exception("Error processing request")
        res = dict()
        res["error"] = str(e)
        return Response(
            content=jsonable_encoder(res),
            status_code=500,
            media_type="application/json",
        )


@app.put(
    "/user/profile/update",
    response_model=project.update_user_profile_service.UpdateUserProfileResponse,
)
async def api_put_update_user_profile(
    email: Optional[str],
    username: Optional[str],
    bio: Optional[str],
    avatar_url: Optional[str],
) -> project.update_user_profile_service.UpdateUserProfileResponse | Response:
    """
    Updates the user's profile information.
    """
    try:
        res = await project.update_user_profile_service.update_user_profile(
            email, username, bio, avatar_url
        )
        return res
    except Exception as e:
        logger.exception("Error processing request")
        res = dict()
        res["error"] = str(e)
        return Response(
            content=jsonable_encoder(res),
            status_code=500,
            media_type="application/json",
        )


@app.get(
    "/user/profile", response_model=project.get_user_profile_service.UserProfileResponse
)
async def api_get_get_user_profile() -> project.get_user_profile_service.UserProfileResponse | Response:
    """
    Retrieves the user's profile information.
    """
    try:
        res = await project.get_user_profile_service.get_user_profile()
        return res
    except Exception as e:
        logger.exception("Error processing request")
        res = dict()
        res["error"] = str(e)
        return Response(
            content=jsonable_encoder(res),
            status_code=500,
            media_type="application/json",
        )
